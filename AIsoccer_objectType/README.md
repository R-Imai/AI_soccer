# AIsoccer
## 概要説明<br>
このプログラムは「openGL」を使用して書かれたプログラムの戦略の部分を使用者それぞれが書き勝敗を競うことを目的として書きました。

## 仕様
### 画面説明<br>
***
このプログラムでは下図のような座標系をとり、よく使用されると思われる座標は、「#define」により以下の文字に同等の値を持たせました。<br>
赤がA チーム青がB チームです。
![grand_info](https://github.com/R-Imai/AI_soccer/blob/master/AIsoccer_functionType/grand_info1.png "画面説明")

## 各クラスの説明
### Playerクラス
***
プレイヤーの情報が書いてあるクラスです。
#### メンバ変数
***
##### double : X , Y , ang
X,Y はそれぞれプレイヤーのx 座標、y 座標です。また、ang はx 軸からの時計回りに
はかった向きの角度で、範囲は「􀀀180◦～180◦」です。<br><br>

##### double : vx , vy , vang
それぞれx の速度、y の速度、角速度です。この値は基本はいじらなくても後述の関数で
自動で与えられます。<br><br>

##### int : mode , cnd , have , re
　mode,cnd は戦略を立てるうえで皆さんに自由に使っていただける変数です。チーム内での分担や、行動の進み具合を表す等自由にお使いください。<br><br>
　have はそのプレーヤーがボールを持っている際は1 それ以外は0 となります。have は自動的に設定されますのでいじらないでください。<br><br>
　re は後述の行動する関数が完了した際に1 となって返されます。行動終了の合図としてお使いください。<br><br>
また、行動終了後に1 となるため、必要のない場合でも
```c
if(A.player[1].re == 1){
  A.player[1].re = 0;
}
```
と記述してください。でないと予期せぬバグを起こすことがあります。<br><br>

##### int : side
sideはそのプレーヤーがどっち側に攻めるかを表す変数です。
チームインスタンス生成時の引数を上に攻めるなら1,下なら-1とするこで自動で設定されます。<br><br>

#### メンバメソッド
***
##### void set(double x, double y, double ang)
setはplayerのx , y , angを一括でセットできる関数です。<br>
***
##### void turn(double ang)
この関数は引数に目標角度(deg) を入力することで目標角度に向かって回転し始めます。<br>
目標角度まで回転した際にはplay.re が1 になって返されますので0 にする操作を入れてください。<br>
###### 使用例(Aに属するplayer[1]を45°に向かせる)
```c
A.player[1].turn(45); 　//A[1] を45◦ の向きに向かせる。
if(A.player[1].re == 1){ 　　　　//A[1] が45◦ になりA[1].re が１になって返ってきたら
　　  A.player[1].cnd++; 　　　　//コマンドを次へ
　　　A.player[1].re = 0; 　　　　//A[1].re を0 に戻す。
}
```

***
##### void turn(Player waiter)
turn(double ang)のオーバーロードで、引数にはPlayerを渡します。<br>
すると、そのプレイヤー目指して回転し始めます。<br>
目標角度まで回転した際にはplay.re が1 になって返されますので0 にする操作を入れてください。<br>
###### 使用例(Ateamに属するplayer[1]を同じチームのplayer[2]に向かせる)
```c
Ateam.player[1].turn(A.player[2]); 　//A[1] をplayer[2]の向きに向かせる。
if(A.player[1].re == 1){ 　　　　//A[1] が45◦ になりA[1].re が１になって返ってきたら
　　  A.player[1].cnd++; 　　　　//コマンドを次へ
　　　A.player[1].re = 0; 　　　　//A[1].re を0 に戻す。
}
```
***
##### void turn_G()
この関数はturn 関数の特殊版で自分たちが攻めるゴールへ向きます。<br>
使用方法はturn 関数と同じです。<br>

***
##### void turn_B()
この関数はturn 関数の特殊版でボールのある方向を向きます。<br>
使用方法はturn 関数と同じです。<br>
***
##### void go()

この関数はただ前に進む関数です。現在の向きに速度を持たせます。<br>
この関数ではplay.re が1 になることはありません。<br>

***
##### void G_go(int meter)
この関数はgo 関数の特殊版で自分たちが攻めるゴールとの距離がmeter になるまで進みます。<br>
go 関数と違い、""行動が完了するとplay.re が1 になって返されますので"" 0 にする操作を入れてください。<br>

***
##### void move(double xx , double yy)
この関数は(xx , yy) を目標地点にして移動する関数です。<br>
この関数では移動が完了したらplay.re が1 になって返されますので0 にする操作を入れてください。<br>
###### 使用例(A.player[1] を(100 , 400) へ移動させる。)
```c
A.player[1].move(100 , 400); 　//player[1] を(100 , 400) へ移動させる。
if(A.player[1].re == 1)｛         //player[1] が移動を完了してA[1].re が１になって返ってきたら
　　　A.player[1].cnd++; 　  　　　//コマンドを次へ
　　　A.player[1].re = 0; 　　　 　//player[1].re を0 に戻す。
｝
```
***

##### void get()

この関数はmove 関数の特殊版でボールを取りに行く関数です。<br>
使用方法はmove 関数と同じです。<br>

***
##### void stop()

この関数はただ速度を0 にする関数です。<br>
この関数では.re が1 になることはありません。<br>

***
##### void pass(Player getter)

この関数はgetter へパスする関数です。<br>
前方30◦ 以内にgetter が存在するまで回転します。その後ボールをgetter へ向かってけりだします。<br>
パスをし終わった際にはplay.re が1 になって返されますので0 にする操作を入れてください。<br>
この関数はボールを所持していないと機能しません。<br>
###### 使用例(A.player[1] からA.player[2] へパスさせる。)
```c
A.player[1].pass(A.player[2]); 　//A[1] からA[2] へパスさせる。
if(A.player[1].re == 1){ 　　　　//A[1] がパスをしてA[1].re が１になって返ってきたら
　　　A.player[1].cnd++; 　　　　//コマンドを次へ
　　　A.player[1].re = 0; 　　　　//A[1].re を0 に戻す。
}
```
***
##### void shoot()

この関数はボールを前方へ蹴る関数です<br>
蹴り終わった際にはplay.re が1 になって返されますので0 にする操作を入れてください。<br>
この関数はボールを所持していないと機能しません。<br>
***
##### double calc passang(P data getter)

この関数はpasserから見たgetterの角度を返します。<br>
パス角度の計算等にお使いください。<br>
***
<br><br>
### Teamクラス
***
チームの情報について書かれている関数です。<br>
主にこのクラスを継承して自分のチームを作っていただきます。
#### メンバ変数
***
##### int side
これはそのチームがどっちに攻めるかを表す変数で1か-1になります。<br>
画面上に攻める(Bチーム)時は1、下に攻める(Aチーム)時は-1をチームインスタンス生成時に引数にしてください。
yに関係する場合にsideで±を指定するとどっち攻めでもうまくいくようになると思います。
***
##### Player player[5]
このチームに属するプレイヤーです。0番のプレイヤーは使わず1番から使用してください。(のちに仕様変更するかもしれないです。)
***

#### メンバメソッド
***
##### virtual void strategy()
この関数が戦略を記述する関数です。<br>
Playerクラスのメソッドを駆使する等をして戦略を組んでください。<br>
例は付属のサンプルプログラムをご覧ください。<br>
***

##### virtual void defence_init()
この関数内には守備の初期の位置と角度を記述してください。(Playerクラスのset()を使用するとサクッといくと思います)また、プレイヤークラス内の変数リセットも記述できます。<br>
###### 例
```c
defence_init(){
  this->player[1].set(500, this->side * 200, -side*90);
  this->player[2].set(-500, this->side * 200, -side*90);
  this->player[3].set(0, this->side * 400, -side*90);
  this->player[4].set(0, this->side * 800, -side*90);
  for(int n = 0; n <= PLAYER; ){
    this->player[n].v = 0;
    this->player[n].vang = 0;
    this->player[n].cnd = 0;
    this->player[n].mode = 0;
  }
}
```
***
##### virtual void offence_init()
この関数内には攻撃の初期の位置と角度を記述してください。<br>
書き方はdefence_init()と同じです。
***
##### virtual void lineover_init()
これはボールが線を割った時の位置等を記述する関数です。<br>
テンプレートのメソッド内にはあらかじめswitch文が書いてあり横にコメントでスローインなどと書いてあります。<br>
それぞれの場合について初期位置等の情報を記述してください。<br>
***
##### void stop()
この関数はチーム全員を止めることができます。
<br><br>
### Ballクラス
***
Ballクラスはボールの情報を表すクラスです。この値は自動的に設定されますので
いじらないでください
#### メンバ変数
##### double : x,y
それぞれボールのx 座標y 座標をあらわしています。
***
##### int : have
ボールの所持者の情報です。この値が正の値ならA チームのプレイヤーが所持、負の値ならB チームのプレイヤーが所持しています。
***
##### int : state
試合の状態です。正の値ならA チーム、負の値ならB チームに所持権があります。<br>
　 　0 : 試合中<br>
　-1,1 : スローイン<br>
　-2,2 : ゴールキック<br>
　-3,3 : コーナーキック<br>
***

## 操作方法
このプログラムはデバック用にキーボード等で開始一時停止ができます。<br>
「左クリック」：ボールをその位置へ移動させ開始<br>
「s」：スタート<br>
「a」：ストップ<br>

## 注意点とお願い
このプログラムはまだ作成途中です。<br>
したがって予期せぬ不具合が起こるかもしれません。その際は制作者へフィードバックをお願いします。<br>
さらにプログラム内のパラメータ等ををいじることでありえない動き等が可能ですが、良識の範囲内でお願いします。<br>
最後にこのプログラムを制作者を介さずに他の人に公開しないでください(制作者に声をかけていただければOKです)。よろしくお願いいたします。<br><br>
現在このマニュアルも試作品なので、不備だらけだと思うので、不明点は遠慮なく制作者へ問い合わせてください。<br>
戦略の書き方のご相談等もわかる範囲で受け付けます。<br><br>

#### 追伸:テンプレートは現在作成途中です。
